### 1. 项目定位
*   **项目名称**：**DeepAudio**
*   **核心目标**：通过 AI 技术将低码率音频（如 128kbps MP3）重构为高保真无损音质（48k-192k FLAC/WAV），解决高频缺失和编码瑕疵。

### 2. 技术栈选型
*   **界面层**：**Flet (Python + Flutter)**
*   **核心算法**：
    *   **AudioSR**：支持 48kHz 输出
    *   **AudioLBM**：96kHz+ 的重构
*   **后勤引擎**：**FFmpeg**。负责格式转换、切片处理、元数据（封面、标签）的提取与封回。
*   **推理框架**：PyTorch (首选) / ONNX Runtime (优化版，用于跨显卡支持)。

### 3. 核心功能设计

#### A. 极致的易用性 (GUI)
*   **全自动化管线**：用户只需“拖入文件 -> 点击开始 -> 获得 FLAC”。
*   **批量处理系统**：支持多任务并行，显示独立进度条、剩余时间预测（ETA）和实时日志。
*   **智能对比预览**：提供“5秒片段试听”功能，生成一小段超分后的音频并支持原音/增强音的一键切换。

#### B. 专业的工程化处理（借鉴视频超分经验）
*   **重叠切片技术 (Overlap-Add)**：借鉴视频超分的 Tiling 逻辑，将长音频分段处理，通过 1-2 秒的重叠区域进行线性淡入淡出混合，彻底消除分段产生的“爆音/咔哒声”。
*   **元数据继承系统**：在超分前后利用 FFmpeg 进行 Demux/Mux，确保输出的 FLAC 完美保留原始封面图、歌手名、专辑名及歌词标签。
*   **频谱可视化**：在界面展示处理前后的频谱图（Spectrogram），让用户直观看到消失的高频如何被 AI “找回”。

#### C. 硬件适配优化
*   **环境自检**：启动时检测 CUDA 环境，若无显卡则自动降级到 CPU 模式。
*   **显存管理**：根据显存大小动态调整分段长度，防止在处理长音频时出现 OOM（内存溢出）。

---

### 4. 业务流程（Pipeline）
1.  **输入分析**：FFmpeg 读取采样率、位深、元数据及封面。
2.  **预处理**：转换为标准化的浮点 WAV 格式，进行必要的降噪或去除编码伪影。
3.  **AI 推理**：
    *   按固定时长切片（带 Overlap）。
    *   送入 AudioSR/AudioLBM 模型。
    *   多线程或单线程循环处理。
4.  **后处理**：
    *   利用 OLA 算法合并音频流。
    *   位深转换（32bit -> 24bit）。
5.  **封装输出**：FFmpeg 将音频流与原始封面、标签封装为 FLAC/WAV。

---

### 5. 项目核心优势（差异化点）
1.  **专注中文歌曲**：针对 80-90 年代中文流行歌的人声表现进行调优（可作为后续迭代的微调方向）。
2.  **工程化完成度**：不仅仅是跑通模型，而是解决了**无缝拼接**和**信息丢失**这两个 AI 音频处理的顽疾。
3.  **零配置体验**：通过便携化打包（Portable Bundle），内置 FFmpeg 和精简版环境，让用户解压即用，无需配置 Python 路径。

---

### 6. 开发路线图 (Roadmap)
*   **Phase 1 (MVP)**：完成 Flet UI 基础架构，实现单文件调用 AudioSR 转换，确保 FFmpeg 能正确导出文件。
*   **Phase 2 (稳定性)**：引入 Overlap-Add 拼接算法，解决长音频爆音问题；集成元数据还原功能。
*   **Phase 3 (体验优化)**：增加批量队列、频谱预览、试听片段生成功能。
*   **Phase 4 (性能跃迁)**：尝试将模型导出为 ONNX，利用 Vulkan/TensorRT 加速，降低对庞大 Python 环境的依赖。
